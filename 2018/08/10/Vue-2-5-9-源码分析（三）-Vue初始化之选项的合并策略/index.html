
<!DOCTYPE html>
<html lang="zh-Hans">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Mengyu&#39;s Notes">
    <title>Vue 2.5.9 源码分析（三） ~ Vue初始化之选项的合并策略 - Mengyu&#39;s Notes</title>
    <meta name="author" content="Mengyu&#39;s Notes">
    
    
        <link rel="icon" href="http://mife.io/assets/images/favicon.ico">
    
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Mengyu's Notes","sameAs":["https://github.com/daqd","mailto:hellojser@gmail.com"],"image":"pic.jpg"},"articleBody":"上一篇，在Vue的合并选项过程中，对props,inject,directives进行了统一的规范化处理，不管框架的使用者在传入初始化选项的时候传入了何种格式，在框架的内部都会转换成统一的数据格式，在提升了框架使用上的灵活性的同时，又保证了框架在内部对数据更加严谨的处理。在之前的分析过程中，我们也遇到了些许疑问，并加上了相应的问题备注，不过，这些暂时不会影响我们继续阅读源码，随着对整体框架的深入的了解，再回看这些问题，这些问题也就不再是问题。\n实际上，本文和上一篇算是一部分，选项合并主要包含了两部分：一部分是对数据的规范化，另一部分就是对不同选项的策略的挂载。这篇，我们紧接着上一篇，对选项的策略挂载进行分析。定义options，这也是最终选项统一化处理和合并策略阶段处理完毕之后，最终的返回值。1const options = &#123;&#125;\n其次对parent进行遍历，还记得parent是什么么？在我们之前的示例中代表的是Vue构造函数的静态属性’options’.123456789101112for (key in parent) &#123;  mergeField(key)&#125;for (key in child) &#123;  if (!hasOwn(parent, key)) &#123;    mergeField(key)  &#125;&#125;function mergeField (key) &#123;  const strat = strats[key] || defaultStrat  options[key] = strat(parent[key], child[key], vm, key)&#125;\n在示例中，首先对components,directives,filters,_base进行遍历，首先从strats中获取到对应的策略方法，找不到的话将默认策略赋给它。我们先看下strats是从哪里来的？12import config from '../config'const strats = config.optionMergeStrategies\n在最开始，定义了strats，其值是从config中导入的optionMergeStrategies，还记得config在哪里用过么？那就是我们在第一篇文章挂载静态方法的阶段，如下：12345Vue.config = &#123;  // user  optionMergeStrategies: &#123; [key: string]: Function &#125;;  ...&#125;\n同时，也可以在官方文档中找到这个配置的相关说明（戳这里），先从config.optionMergeStrategies拿到用户自定义的合并策略方法。在这基础之上，开始定义对各个初始化选项的策略方法。\ndefaultStrat12345678/** * Default strategy. */const defaultStrat = function (parentVal: any, childVal: any): any &#123;  return childVal === undefined    ? parentVal    : childVal&#125;\n默认策略，接受两个参数父实例和子实例，内部先判断childVal是否被传入，传入的话返回childVal，不存在的话，返回父实例。\nel &amp; propsData1234567891011if (process.env.NODE_ENV !== 'production') &#123;  strats.el = strats.propsData = function (parent, child, vm, key) &#123;    if (!vm) &#123;      warn(        `option \"$&#123;key&#125;\" can only be used during instance ` +        'creation with the `new` keyword.'      )    &#125;    return defaultStrat(parent, child)  &#125;&#125;\n在非生产环境下，对options中的el和propsData进行处理的时候，会校验当前的实例是否存在，不存在会有相应的提示。非生产环境下会直接返回默认策略defaultStrat，生产环境下也会因为const strat = strats[key] || defaultStrat，先是在strats下找不到el和propsData,之后直接执行默认策略。\ndata对data的策略方法的一开始，便首先判断了当前是否存在实例：123456789101112131415161718192021strats.data = function (  parentVal: any,  childVal: any,  vm?: Component): ?Function &#123;  if (!vm) &#123;    if (childVal &amp;&amp; typeof childVal !== 'function') &#123;      process.env.NODE_ENV !== 'production' &amp;&amp; warn(        'The \"data\" option should be a function ' +        'that returns a per-instance value in component ' +        'definitions.',        vm      )      return parentVal    &#125;    return mergeDataOrFn(parentVal, childVal)  &#125;  return mergeDataOrFn(parentVal, childVal, vm)&#125;\n\n不存在实例vm：\n判断当前传入的初始化data选项是否是一个函数（之前的示例，data一直都是一个对象，官方文档中有提到data应该是一个返回对象的函数，后面我们在分析其到底是为什么）,不是函数的话直接返回父实例的data项\n是一个函数的话，会调用mergeDataOrFn,并将父实例和子实例作为参数传进去\n\n\n存在实例vm,会调用mergeDataOrFn,并将构造函数和传入的当前配置项、vm实例、作为参数传进去\n\n在我们这里示例中，会直接执行mergeDataOrFn(parentVal, childVal, vm),来看mergeDataOrFn:123456789101112131415161718if (!vm) &#123;\t...&#125; else &#123;  return function mergedInstanceDataFn () &#123;    // instance merge    const instanceData = typeof childVal === 'function'      ? childVal.call(vm)      : childVal    const defaultData = typeof parentVal === 'function'      ? parentVal.call(vm)      : parentVal    if (instanceData) &#123;      return mergeData(instanceData, defaultData)    &#125; else &#123;      return defaultData    &#125;  &#125;&#125;\n因为在Vue的初始化过程中，第一次初始化data时执行到这里，是可以获取到vm的,从代码原作者的注释中(// in a Vue.extend merge, both should be functions)也可以看出，上面省略的部分跟Vue.extend有关，我们先按照示例走，在这里会返回一个mergedInstanceDataFn函数，所以最终options.data = mergedInstanceDataFn(){}。\n生命周期函数策略首先从shared/onstant.js中，引入了所有的生命周期方法：12345678910111213export const LIFECYCLE_HOOKS = [  'beforeCreate',  'created',  'beforeMount',  'mounted',  'beforeUpdate',  'updated',  'beforeDestroy',  'destroyed',  'activated',  'deactivated',  'errorCaptured']\n之后为所有的生命周期函数挂载了统一的策略函数mergeHook，我们来看下mergeHook:123456789101112function mergeHook (  parentVal: ?Array&lt;Function&gt;,  childVal: ?Function | ?Array&lt;Function&gt;): ?Array&lt;Function&gt; &#123;  return childVal    ? parentVal      ? parentVal.concat(childVal)      : Array.isArray(childVal)        ? childVal        : [childVal]    : parentVal&#125;\n\n在子实例中是否有该项生命周期函数：\n在父实例中是否有该项生命周期函数：\n是，将父实例和子实例进行合并\n否，判断当前子实例中该项是否为一个数组，不为数组的转换成一个数组\n\n\n\n\n没有相关项，直接返回父实例的该项\n\n所以，最终options[生命周期名称] = [数组项]\ncomponent &amp; directive &amp; filter首先从shared/onstant.js中，引入了静态类型的选项名称：12345export const ASSET_TYPES = [  'component',  'directive',  'filter']\n统一的策略函数mergeAssets，我们来看下mergeAssets:1234567891011121314function mergeAssets (  parentVal: ?Object,  childVal: ?Object,  vm?: Component,  key: string): Object &#123;  const res = Object.create(parentVal || null)  if (childVal) &#123;    process.env.NODE_ENV !== 'production' &amp;&amp; assertObjectType(key, childVal, vm)    return extend(res, childVal)  &#125; else &#123;    return res  &#125;&#125;\n首先从父实例上缓存相关项的值，没有的话通过Object.create(null)创建一个空对象。之后在判断子实例中是否存在该项，在非生产环境下还需要通过assertObjectType校验格式并有相应的提示：\n\n如果含有该项，需要将子实例的该项复制合并到父实例的该项\n无该项，直接返回父实例的该项或空对象\n\nwatch123// work around Firefox's Object.prototype.watch...if (parentVal === nativeWatch) parentVal = undefinedif (childVal === nativeWatch) childVal = undefined\n判断parentVal或者childVal是否是Object.prototype.watch，在Gecko下有watch的API的实现，详细信息戳这里(MDN),避免Vue的watch方法和原型上的watch方法冲突，如果是FireFox下的，先将parentVal或者childVal重置为undefined。\n1if (!childVal) return Object.create(parentVal || null)\n如果子实例不存在该项，直接返回父实例的该项或者一个空对象。123if (process.env.NODE_ENV !== 'production') &#123;  assertObjectType(key, childVal, vm)&#125;\n非生产环境下还需要校验当前的类型，给给出相应的提示信息。1if (!parentVal) return childVal\n如果父实例不存在该项，直接返回子实例的该项，在我们的例子中便直接返回传入的watch项。\n123456789101112const ret = &#123;&#125;extend(ret, parentVal)for (const key in childVal) &#123;  let parent = ret[key]  const child = childVal[key]  if (parent &amp;&amp; !Array.isArray(parent)) &#123;    parent = [parent]  &#125;  ret[key] = parent    ? parent.concat(child)    : Array.isArray(child) ? child : [child]&#125;\n最后是父实例和子实例中都含有watch项，那么要进行合并处理。合并的主要过程就是：\n\n首先定义一个常量ret，将父实例的watch项合并到ret.\n遍历子实例的watch\n在遍历的过程中，判断父实例是否拥有很子实例同样名称的watch：\n有，则将父实例和子实例的watch合并成一个数组。\n没有，直接将子实例返回就行\n\n\n\n其中，返回的都是一个数组，如果在处理的过程中，父实例和子实例的watch不是Array的时候，会通过[]进行包起来转换成数组。\nprops &amp; methods &amp; inject &amp; computed接下来会对这四个选项进行处理，先判断其类型，并在生产环境下给出提示：123if (childVal &amp;&amp; process.env.NODE_ENV !== 'production') &#123;  assertObjectType(key, childVal, vm)&#125;\n父实例不包含该项，直接返回子实例即可：1if (!parentVal) return childVal\n父子实例都存在该项的话，将两个进行合并返回：1234const ret = Object.create(null)extend(ret, parentVal)if (childVal) extend(ret, childVal)return ret\nprovide最后是provide的合并策略，其策略函数是mergeDataOrFn，这个函数在data的合并策略介绍过。\n完整示例最后，我们用之前的例子，将所有选项填满，通过运行Vue在Debug中整体看一下options的返回值：12345678910111213141516171819202122232425262728293031323334353637383940var demo = new Vue(&#123;  data()&#123;  \treturn &#123;\t    a:1\t  &#125;  &#125;,  el:'#demo',  propsData: &#123;    msg: 'hello'  &#125;,  mounted()&#123;  \tconsole.log(\"创建喽！\");  &#125;,  directives: &#123;\tfocus: &#123;\t// 指令的定义\tinserted: function (el) &#123;\t  el.focus()\t&#125;\t&#125;  &#125;,  watch:&#123;  \twatchA()&#123;  \t\tconsole.log('watchA');  \t&#125;,  \twatchB()&#123;  \t\tconsole.log('watchB');  \t&#125;  &#125;,  methods:&#123;  \tsayHello()&#123;  \t\tconsole.log('hello MIFE');  \t&#125;  &#125;,  provide: &#123;    foo: 'bar'  &#125;,  props:['js-bridge','vueprops'],  inject:['inject-test1','inject-test2']&#125;)\n\n(完)\n","dateCreated":"2018-08-10T17:00:22+08:00","dateModified":"2018-08-12T20:48:54+08:00","datePublished":"2018-08-10T17:00:22+08:00","description":"上一篇，在Vue的合并选项过程中，对props,inject,directives进行了统一的规范化处理，不管框架的使用者在传入初始化选项的时候传入了何种格式，在框架的内部都会转换成统一的数据格式，在提升了框架使用上的灵活性的同时，又保证了框架在内部对数据更加严谨的处理。在之前的分析过程中，我们也遇到了些许疑问，并加上了相应的问题备注，不过，这些暂时不会影响我们继续阅读源码，随着对整体框架的深入的了解，再回看这些问题，这些问题也就不再是问题。\n实际上，本文和上一篇算是一部分，选项合并主要包含了两部分：一部分是对数据的规范化，另一部分就是对不同选项的策略的挂载。这篇，我们紧接着上一篇，对选项的策略挂载进行分析。","headline":"Vue 2.5.9 源码分析（三） ~ Vue初始化之选项的合并策略","image":[],"mainEntityOfPage":{"@type":"WebPage","@id":"http://mife.io/2018/08/10/Vue-2-5-9-源码分析（三）-Vue初始化之选项的合并策略/"},"publisher":{"@type":"Organization","name":"Mengyu's Notes","sameAs":["https://github.com/daqd","mailto:hellojser@gmail.com"],"image":"pic.jpg","logo":{"@type":"ImageObject","url":"pic.jpg"}},"url":"http://mife.io/2018/08/10/Vue-2-5-9-源码分析（三）-Vue初始化之选项的合并策略/","keywords":"源码分析, Vue源码分析"}</script>
    <meta name="description" content="上一篇，在Vue的合并选项过程中，对props,inject,directives进行了统一的规范化处理，不管框架的使用者在传入初始化选项的时候传入了何种格式，在框架的内部都会转换成统一的数据格式，在提升了框架使用上的灵活性的同时，又保证了框架在内部对数据更加严谨的处理。在之前的分析过程中，我们也遇到了些许疑问，并加上了相应的问题备注，不过，这些暂时不会影响我们继续阅读源码，随着对整体框架的深入的">
<meta name="keywords" content="源码分析,Vue源码分析">
<meta property="og:type" content="blog">
<meta property="og:title" content="Vue 2.5.9 源码分析（三） ~ Vue初始化之选项的合并策略">
<meta property="og:url" content="http://mife.io/2018/08/10/Vue-2-5-9-源码分析（三）-Vue初始化之选项的合并策略/index.html">
<meta property="og:site_name" content="Mengyu&#39;s Notes">
<meta property="og:description" content="上一篇，在Vue的合并选项过程中，对props,inject,directives进行了统一的规范化处理，不管框架的使用者在传入初始化选项的时候传入了何种格式，在框架的内部都会转换成统一的数据格式，在提升了框架使用上的灵活性的同时，又保证了框架在内部对数据更加严谨的处理。在之前的分析过程中，我们也遇到了些许疑问，并加上了相应的问题备注，不过，这些暂时不会影响我们继续阅读源码，随着对整体框架的深入的">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://mife.io/images/2018/8/vue-3/debugger_options.png">
<meta property="og:updated_time" content="2018-08-12T12:48:54.472Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Vue 2.5.9 源码分析（三） ~ Vue初始化之选项的合并策略">
<meta name="twitter:description" content="上一篇，在Vue的合并选项过程中，对props,inject,directives进行了统一的规范化处理，不管框架的使用者在传入初始化选项的时候传入了何种格式，在框架的内部都会转换成统一的数据格式，在提升了框架使用上的灵活性的同时，又保证了框架在内部对数据更加严谨的处理。在之前的分析过程中，我们也遇到了些许疑问，并加上了相应的问题备注，不过，这些暂时不会影响我们继续阅读源码，随着对整体框架的深入的">
<meta name="twitter:image" content="http://mife.io/images/2018/8/vue-3/debugger_options.png">
    
    
        
    
    
        <meta property="og:image" content="http://mife.io/assets/images/pic.jpg"/>
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/style-1udptkpril81ozu8ifd8zpujn7ipu7lefxsiu5gxx0dpnzntdx6dusvki3ao.min.css">
    <!--STYLES END-->
    

    
    <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?3689bb8a19409b583596dd91730d27d6";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="2">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a class="header-title-link" href="/ ">Mengyu&#39;s Notes</a>
    </div>
    
        
            <a  class="header-right-picture "
                href="#about">
        
        
            <img class="header-picture" src="/assets/images/pic.jpg" alt="Author&#39;s picture"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="2">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a href="/#about">
                    <img class="sidebar-profile-picture" src="/assets/images/pic.jpg" alt="Author&#39;s picture"/>
                </a>
                <h4 class="sidebar-profile-name">Mengyu&#39;s Notes</h4>
                
                    <h5 class="sidebar-profile-bio"><p>一身情怀，两手空空</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/ "
                            
                            title="Home"
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-archives"
                            
                            title="Archives"
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Archives</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-categories"
                            
                            title="Categories"
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Categories</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-tags"
                            
                            title="Tags"
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Tags</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="#about"
                            
                            title="About"
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-user" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">About</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://github.com/daqd" target="_blank" rel="noopener" title="GitHub">
                    
                        <i class="sidebar-button-icon fa fa-lg fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="mailto:hellojser@gmail.com" target="_blank" rel="noopener" title="Mail">
                    
                        <i class="sidebar-button-icon fa fa-lg fa-envelope-o" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Mail</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="2"
                 class="
                        hasCoverMetaIn
                        ">
                
<article class="post">
    
    
        <div class="post-header main-content-wrap text-left">
    
        <h1 class="post-title">
            Vue 2.5.9 源码分析（三） ~ Vue初始化之选项的合并策略
        </h1>
    
    
        <div class="post-meta">
    <time datetime="2018-08-10T17:00:22+08:00">
	
		    Aug 10, 2018
    	
    </time>
    
</div>

    
</div>

    
    <div class="post-content markdown">
        <div class="main-content-wrap">
            <p>上一篇，在Vue的合并选项过程中，对<code>props</code>,<code>inject</code>,<code>directives</code>进行了统一的规范化处理，不管框架的使用者在传入初始化选项的时候传入了何种格式，在框架的内部都会转换成统一的数据格式，在提升了框架使用上的灵活性的同时，又保证了框架在内部对数据更加严谨的处理。在之前的分析过程中，我们也遇到了些许疑问，并加上了相应的问题备注，不过，这些暂时不会影响我们继续阅读源码，随着对整体框架的深入的了解，再回看这些问题，这些问题也就不再是问题。</p>
<p>实际上，本文和上一篇算是一部分，选项合并主要包含了两部分：一部分是对数据的规范化，另一部分就是对不同选项的策略的挂载。这篇，我们紧接着上一篇，对选项的策略挂载进行分析。<br><a id="more"></a><br>定义options，这也是最终选项统一化处理和合并策略阶段处理完毕之后，最终的返回值。<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> options = &#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>其次对parent进行遍历，还记得parent是什么么？在我们之前的示例中代表的是Vue构造函数的静态属性’options’.<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">key</span> <span class="keyword">in</span> parent) &#123;</span><br><span class="line">  mergeField(<span class="built_in">key</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">key</span> <span class="keyword">in</span> child) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!hasOwn(parent, <span class="built_in">key</span>)) &#123;</span><br><span class="line">    mergeField(<span class="built_in">key</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">function mergeField (<span class="built_in">key</span>) &#123;</span><br><span class="line">  const strat = strats[<span class="built_in">key</span>] || defaultStrat</span><br><span class="line">  options[<span class="built_in">key</span>] = strat(parent[<span class="built_in">key</span>], child[<span class="built_in">key</span>], vm, <span class="built_in">key</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在示例中，首先对<code>components</code>,<code>directives</code>,<code>filters</code>,<code>_base</code>进行遍历，首先从<code>strats</code>中获取到对应的策略方法，找不到的话将默认策略赋给它。我们先看下strats是从哪里来的？<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="built_in">config</span> from <span class="string">'../config'</span></span><br><span class="line"><span class="keyword">const</span> strats = <span class="built_in">config</span>.optionMergeStrategies</span><br></pre></td></tr></table></figure></p>
<p>在最开始，定义了strats，其值是从config中导入的optionMergeStrategies，还记得config在哪里用过么？那就是我们在第一篇文章挂载静态方法的阶段，如下：<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Vue.config = &#123;</span><br><span class="line">  // user</span><br><span class="line">  optionMergeStrategies: &#123; [key: <span class="keyword">string</span>]: Function &#125;;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>同时，也可以在官方文档中找到这个配置的相关说明（<a href="https://cn.vuejs.org/v2/api/#optionMergeStrategies" target="_blank" rel="noopener">戳这里</a>），先从config.optionMergeStrategies拿到用户自定义的合并策略方法。在这基础之上，开始定义对各个初始化选项的策略方法。</p>
<h4 id="defaultStrat"><a href="#defaultStrat" class="headerlink" title="defaultStrat"></a>defaultStrat</h4><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Default strategy.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> defaultStrat = <span class="function"><span class="keyword">function</span> <span class="params">(parentVal: any, childVal: any)</span>: any </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> childVal === <span class="literal">undefined</span></span><br><span class="line">    ? parentVal</span><br><span class="line">    : childVal</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认策略，接受两个参数父实例和子实例，内部先判断childVal是否被传入，传入的话返回childVal，不存在的话，返回父实例。</p>
<h4 id="el-amp-propsData"><a href="#el-amp-propsData" class="headerlink" title="el &amp; propsData"></a>el &amp; propsData</h4><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if (process.env.NODE_ENV !== 'production') &#123;</span><br><span class="line">  strats.el = strats.propsData = function (parent, child, vm, key) &#123;</span><br><span class="line">   <span class="built_in"> if </span>(!vm) &#123;</span><br><span class="line">      warn(</span><br><span class="line">        `option <span class="string">"$&#123;key&#125;"</span> can only be used during<span class="built_in"> instance </span>` +</span><br><span class="line">        'creation with the `new` keyword.'</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="built_in"> return </span>defaultStrat(parent, child)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在非生产环境下，对options中的el和propsData进行处理的时候，会校验当前的实例是否存在，不存在会有相应的提示。非生产环境下会直接返回默认策略<code>defaultStrat</code>，生产环境下也会因为<code>const strat = strats[key] || defaultStrat</code>，先是在strats下找不到el和propsData,之后直接执行默认策略。</p>
<h4 id="data"><a href="#data" class="headerlink" title="data"></a>data</h4><p>对data的策略方法的一开始，便首先判断了当前是否存在实例：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">strats.data = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  parentVal: <span class="built_in">any</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  childVal: <span class="built_in">any</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  vm?: Component</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): ?<span class="title">Function</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!vm) &#123;</span><br><span class="line">    <span class="keyword">if</span> (childVal &amp;&amp; <span class="keyword">typeof</span> childVal !== <span class="string">'function'</span>) &#123;</span><br><span class="line">      process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; warn(</span><br><span class="line">        <span class="string">'The "data" option should be a function '</span> +</span><br><span class="line">        <span class="string">'that returns a per-instance value in component '</span> +</span><br><span class="line">        <span class="string">'definitions.'</span>,</span><br><span class="line">        vm</span><br><span class="line">      )</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> parentVal</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mergeDataOrFn(parentVal, childVal)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> mergeDataOrFn(parentVal, childVal, vm)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>不存在实例vm：<ul>
<li>判断当前传入的初始化data选项是否是一个函数<em>（之前的示例，data一直都是一个对象，官方文档中有提到data应该是一个返回对象的函数，后面我们在分析其到底是为什么）</em>,不是函数的话直接返回父实例的data项</li>
<li>是一个函数的话，会调用mergeDataOrFn,并将父实例和子实例作为参数传进去</li>
</ul>
</li>
<li>存在实例vm,会调用mergeDataOrFn,并将构造函数和传入的当前配置项、vm实例、作为参数传进去</li>
</ul>
<p>在我们这里示例中，会直接执行<code>mergeDataOrFn(parentVal, childVal, vm)</code>,来看<code>mergeDataOrFn</code>:<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!vm) &#123;</span><br><span class="line">	...</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">mergedInstanceDataFn</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// instance merge</span></span><br><span class="line">    <span class="keyword">const</span> instanceData = <span class="keyword">typeof</span> childVal === <span class="string">'function'</span></span><br><span class="line">      ? childVal.call(vm)</span><br><span class="line">      : childVal</span><br><span class="line">    <span class="keyword">const</span> defaultData = <span class="keyword">typeof</span> parentVal === <span class="string">'function'</span></span><br><span class="line">      ? parentVal.call(vm)</span><br><span class="line">      : parentVal</span><br><span class="line">    <span class="keyword">if</span> (instanceData) &#123;</span><br><span class="line">      <span class="keyword">return</span> mergeData(instanceData, defaultData)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> defaultData</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因为在Vue的初始化过程中，第一次初始化data时执行到这里，是可以获取到vm的,从代码原作者的注释中<em>(// in a Vue.extend merge, both should be functions)</em>也可以看出，上面省略的部分跟Vue.extend有关，我们先按照示例走，在这里会返回一个<code>mergedInstanceDataFn</code>函数，所以最终<code>options.data = mergedInstanceDataFn(){}</code>。</p>
<h4 id="生命周期函数策略"><a href="#生命周期函数策略" class="headerlink" title="生命周期函数策略"></a>生命周期函数策略</h4><p>首先从<code>shared/onstant.js</code>中，引入了所有的生命周期方法：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> LIFECYCLE_HOOKS = [</span><br><span class="line">  <span class="string">'beforeCreate'</span>,</span><br><span class="line">  <span class="string">'created'</span>,</span><br><span class="line">  <span class="string">'beforeMount'</span>,</span><br><span class="line">  <span class="string">'mounted'</span>,</span><br><span class="line">  <span class="string">'beforeUpdate'</span>,</span><br><span class="line">  <span class="string">'updated'</span>,</span><br><span class="line">  <span class="string">'beforeDestroy'</span>,</span><br><span class="line">  <span class="string">'destroyed'</span>,</span><br><span class="line">  <span class="string">'activated'</span>,</span><br><span class="line">  <span class="string">'deactivated'</span>,</span><br><span class="line">  <span class="string">'errorCaptured'</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>之后为所有的生命周期函数挂载了统一的策略函数<code>mergeHook</code>，我们来看下<code>mergeHook</code>:<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title">mergeHook</span> (</span><br><span class="line">  parentVal: ?Array&lt;<span class="keyword">Function</span>&gt;,</span><br><span class="line">  childVal: ?<span class="keyword">Function</span> <span class="title">|</span> ?Array&lt;<span class="keyword">Function</span>&gt;</span><br><span class="line">): ?Array&lt;<span class="keyword">Function</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="type">childVal</span></span><br><span class="line">    ? parentVal</span><br><span class="line">      ? parentVal.concat(childVal)</span><br><span class="line">      : <span class="type">Array.isArray</span>(childVal)</span><br><span class="line">        ? childVal</span><br><span class="line">        : [<span class="type">childVal</span>]</span><br><span class="line">    : <span class="type">parentVal</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>在子实例中是否有该项生命周期函数：<ul>
<li>在父实例中是否有该项生命周期函数：<ul>
<li>是，将父实例和子实例进行合并</li>
<li>否，判断当前子实例中该项是否为一个数组，不为数组的转换成一个数组</li>
</ul>
</li>
</ul>
</li>
<li>没有相关项，直接返回父实例的该项</li>
</ul>
<p>所以，最终options[生命周期名称] = [数组项]</p>
<h4 id="component-amp-directive-amp-filter"><a href="#component-amp-directive-amp-filter" class="headerlink" title="component &amp; directive &amp; filter"></a>component &amp; directive &amp; filter</h4><p>首先从<code>shared/onstant.js</code>中，引入了静态类型的选项名称：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ASSET_TYPES = [</span><br><span class="line">  <span class="string">'component'</span>,</span><br><span class="line">  <span class="string">'directive'</span>,</span><br><span class="line">  <span class="string">'filter'</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>统一的策略函数<code>mergeAssets</code>，我们来看下<code>mergeAssets</code>:<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function mergeAssets (</span><br><span class="line">  parentVal: ?<span class="keyword">Object</span>,</span><br><span class="line">  childVal: ?<span class="keyword">Object</span>,</span><br><span class="line">  vm?: Component,</span><br><span class="line">  <span class="built_in">key</span>: string</span><br><span class="line">): <span class="keyword">Object</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">Object</span>.create(parentVal || <span class="keyword">null</span>)</span><br><span class="line">  <span class="keyword">if</span> (childVal) &#123;</span><br><span class="line">    process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; assertObjectType(<span class="built_in">key</span>, childVal, vm)</span><br><span class="line">    <span class="keyword">return</span> extend(res, childVal)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先从父实例上缓存相关项的值，没有的话通过Object.create(null)创建一个空对象。之后在判断子实例中是否存在该项，在非生产环境下还需要通过<code>assertObjectType</code>校验格式并有相应的提示：</p>
<ul>
<li>如果含有该项，需要将子实例的该项复制合并到父实例的该项</li>
<li>无该项，直接返回父实例的该项或空对象</li>
</ul>
<h4 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h4><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">//</span> work around Firefox's Object.prototype.watch.<span class="string">..</span></span><br><span class="line"><span class="keyword">if</span> <span class="params">(<span class="attr">parentVal</span> === nativeWatch)</span> parentVal = undefined</span><br><span class="line"><span class="keyword">if</span> <span class="params">(<span class="attr">childVal</span> === nativeWatch)</span> childVal = undefined</span><br></pre></td></tr></table></figure>
<p>判断parentVal或者childVal是否是Object.prototype.watch，在Gecko下有watch的API的实现，详细信息戳这里(<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/watch" target="_blank" rel="noopener">MDN</a>),避免Vue的watch方法和原型上的watch方法冲突，如果是FireFox下的，先将parentVal或者childVal重置为undefined。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!childVal) <span class="keyword">return</span> <span class="built_in">Object</span>.create(parentVal || <span class="keyword">null</span>)</span><br></pre></td></tr></table></figure>
<p>如果子实例不存在该项，直接返回父实例的该项或者一个空对象。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (process<span class="selector-class">.env</span><span class="selector-class">.NODE_ENV</span> !== <span class="string">'production'</span>) &#123;</span><br><span class="line">  assertObjectType(key, childVal, vm)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>非生产环境下还需要校验当前的类型，给给出相应的提示信息。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!parentVal) <span class="keyword">return</span> childVal</span><br></pre></td></tr></table></figure></p>
<p>如果父实例不存在该项，直接返回子实例的该项，在我们的例子中便直接返回传入的watch项。</p>
<figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ret = &#123;&#125;</span><br><span class="line">extend(ret, parentVal)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> childVal) &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="built_in">parent</span> = ret[key]</span><br><span class="line">  <span class="keyword">const</span> child = childVal[key]</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">parent</span> &amp;&amp; !<span class="built_in">Array</span>.isArray(<span class="built_in">parent</span>)) &#123;</span><br><span class="line">    <span class="built_in">parent</span> = [<span class="built_in">parent</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  ret[key] = <span class="built_in">parent</span></span><br><span class="line">    ? <span class="built_in">parent</span>.concat(child)</span><br><span class="line">    : <span class="built_in">Array</span>.isArray(child) ? <span class="attribute">child</span> : [child]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后是父实例和子实例中都含有watch项，那么要进行合并处理。合并的主要过程就是：</p>
<ul>
<li>首先定义一个常量ret，将父实例的watch项合并到ret.</li>
<li>遍历子实例的watch</li>
<li>在遍历的过程中，判断父实例是否拥有很子实例同样名称的watch：<ul>
<li>有，则将父实例和子实例的watch合并成一个数组。</li>
<li>没有，直接将子实例返回就行</li>
</ul>
</li>
</ul>
<p>其中，返回的都是一个数组，如果在处理的过程中，父实例和子实例的watch不是Array的时候，会通过[]进行包起来转换成数组。</p>
<h4 id="props-amp-methods-amp-inject-amp-computed"><a href="#props-amp-methods-amp-inject-amp-computed" class="headerlink" title="props &amp; methods &amp; inject &amp; computed"></a>props &amp; methods &amp; inject &amp; computed</h4><p>接下来会对这四个选项进行处理，先判断其类型，并在生产环境下给出提示：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (childVal &amp;&amp; process<span class="selector-class">.env</span><span class="selector-class">.NODE_ENV</span> !== <span class="string">'production'</span>) &#123;</span><br><span class="line">  assertObjectType(key, childVal, vm)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>父实例不包含该项，直接返回子实例即可：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!parentVal) <span class="keyword">return</span> childVal</span><br></pre></td></tr></table></figure></p>
<p>父子实例都存在该项的话，将两个进行合并返回：<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const <span class="keyword">ret</span> = Object.create(null)</span><br><span class="line"><span class="built_in">extend</span>(<span class="keyword">ret</span>, parentVal)</span><br><span class="line"><span class="keyword">if</span> (childVal) <span class="built_in">extend</span>(<span class="keyword">ret</span>, childVal)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">ret</span></span><br></pre></td></tr></table></figure></p>
<h4 id="provide"><a href="#provide" class="headerlink" title="provide"></a>provide</h4><p>最后是provide的合并策略，其策略函数是<code>mergeDataOrFn</code>，这个函数在data的合并策略介绍过。</p>
<h2 id="完整示例"><a href="#完整示例" class="headerlink" title="完整示例"></a>完整示例</h2><p>最后，我们用之前的例子，将所有选项填满，通过运行Vue在Debug中整体看一下options的返回值：<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">var demo = new Vue(&#123;</span><br><span class="line">  data()&#123;</span><br><span class="line">  	return &#123;</span><br><span class="line">	    a:<span class="number">1</span></span><br><span class="line">	  &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  el:<span class="string">'#demo'</span>,</span><br><span class="line">  propsData: &#123;</span><br><span class="line">    msg: <span class="string">'hello'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mounted()&#123;</span><br><span class="line">  	console.log(<span class="string">"创建喽！"</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  directives: &#123;</span><br><span class="line">	focus: &#123;</span><br><span class="line">	// 指令的定义</span><br><span class="line">	inserted: function (el) &#123;</span><br><span class="line">	  el.focus()</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch:&#123;</span><br><span class="line">  	watchA()&#123;</span><br><span class="line">  		console.log(<span class="string">'watchA'</span>);</span><br><span class="line">  	&#125;,</span><br><span class="line">  	watchB()&#123;</span><br><span class="line">  		console.log(<span class="string">'watchB'</span>);</span><br><span class="line">  	&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods:&#123;</span><br><span class="line">  	sayHello()&#123;</span><br><span class="line">  		console.log(<span class="string">'hello MIFE'</span>);</span><br><span class="line">  	&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  provide: &#123;</span><br><span class="line">    foo: <span class="string">'bar'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  props:[<span class="string">'js-bridge'</span>,<span class="string">'vueprops'</span>],</span><br><span class="line">  inject:[<span class="string">'inject-test1'</span>,<span class="string">'inject-test2'</span>]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p><img src="/images/2018/8/vue-3/debugger_options.png" alt="debugger_options"></p>
<p>(完)</p>

            

        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
            <div class="post-footer-tags">
                <span class="text-color-light text-small">TAGGED IN</span><br/>
                
    <a class="tag tag--primary tag--small t-link" href="/tags/Vue源码分析/">Vue源码分析</a> <a class="tag tag--primary tag--small t-link" href="/tags/源码分析/">源码分析</a>

            </div>
        
        
            <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2018/08/11/电影《一出好戏》观感/" data-tooltip="电影《一出好戏》观感" aria-label="PREVIOUS: 电影《一出好戏》观感">
                
                    <i class="fa fa-angle-left" aria-hidden="true"></i>
                    <span class="hide-xs hide-sm text-small icon-ml">PREVIOUS</span>
                </a>
            </li>
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2018/08/08/Vue-2-5-9-源码分析（二）-Vue初始化之选项的合并及统一规范化处理/" data-tooltip="Vue 2.5.9 源码分析（二） ~ Vue初始化之选项的合并及统一规范化处理" aria-label="NEXT: Vue 2.5.9 源码分析（二） ~ Vue初始化之选项的合并及统一规范化处理">
                
                    <span class="hide-xs hide-sm text-small icon-mr">NEXT</span>
                    <i class="fa fa-angle-right" aria-hidden="true"></i>
                </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Share this post">
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="http://service.weibo.com/share/share.php?&amp;title=http://mife.io/2018/08/10/Vue-2-5-9-源码分析（三）-Vue初始化之选项的合并策略/" title="Share on Weibo">
                    <i class="fa fa-weibo" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="http://connect.qq.com/widget/shareqq/index.html?url=http://mife.io/2018/08/10/Vue-2-5-9-源码分析（三）-Vue初始化之选项的合并策略/&amp;title=Vue 2.5.9 源码分析（三） ~ Vue初始化之选项的合并策略" title="Share on QQ">
                    <i class="fa fa-qq" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=http://mife.io/2018/08/10/Vue-2-5-9-源码分析（三）-Vue初始化之选项的合并策略/" title="Share on Qzone">
                    <i class="fa fa-star" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
                <li class="post-action">
                    <a class="post-action-btn btn btn--default" href="#disqus_thread">
                        <i class="fa fa-comment-o"></i>
                    </a>
                </li>
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Back to top">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


        
        
            
                <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
            
        
    </div>
</article>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2018 Mengyu&#39;s Notes. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="2">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2018/08/11/电影《一出好戏》观感/" data-tooltip="电影《一出好戏》观感" aria-label="PREVIOUS: 电影《一出好戏》观感">
                
                    <i class="fa fa-angle-left" aria-hidden="true"></i>
                    <span class="hide-xs hide-sm text-small icon-ml">PREVIOUS</span>
                </a>
            </li>
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2018/08/08/Vue-2-5-9-源码分析（二）-Vue初始化之选项的合并及统一规范化处理/" data-tooltip="Vue 2.5.9 源码分析（二） ~ Vue初始化之选项的合并及统一规范化处理" aria-label="NEXT: Vue 2.5.9 源码分析（二） ~ Vue初始化之选项的合并及统一规范化处理">
                
                    <span class="hide-xs hide-sm text-small icon-mr">NEXT</span>
                    <i class="fa fa-angle-right" aria-hidden="true"></i>
                </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Share this post">
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="http://service.weibo.com/share/share.php?&amp;title=http://mife.io/2018/08/10/Vue-2-5-9-源码分析（三）-Vue初始化之选项的合并策略/" title="Share on Weibo">
                    <i class="fa fa-weibo" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="http://connect.qq.com/widget/shareqq/index.html?url=http://mife.io/2018/08/10/Vue-2-5-9-源码分析（三）-Vue初始化之选项的合并策略/&amp;title=Vue 2.5.9 源码分析（三） ~ Vue初始化之选项的合并策略" title="Share on QQ">
                    <i class="fa fa-qq" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=http://mife.io/2018/08/10/Vue-2-5-9-源码分析（三）-Vue初始化之选项的合并策略/" title="Share on Qzone">
                    <i class="fa fa-star" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
                <li class="post-action">
                    <a class="post-action-btn btn btn--default" href="#disqus_thread">
                        <i class="fa fa-comment-o"></i>
                    </a>
                </li>
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Back to top">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                <div id="share-options-bar" class="share-options-bar" data-behavior="2">
    <i id="btn-close-shareoptions" class="fa fa-close"></i>
    <ul class="share-options">
        
            
            
            <li class="share-option">
                <a class="share-option-btn" target="new" href="http://service.weibo.com/share/share.php?&amp;title=http://mife.io/2018/08/10/Vue-2-5-9-源码分析（三）-Vue初始化之选项的合并策略/">
                    <i class="fa fa-weibo" aria-hidden="true"></i><span>Share on Weibo</span>
                </a>
            </li>
        
            
            
            <li class="share-option">
                <a class="share-option-btn" target="new" href="http://connect.qq.com/widget/shareqq/index.html?url=http://mife.io/2018/08/10/Vue-2-5-9-源码分析（三）-Vue初始化之选项的合并策略/&amp;title=Vue 2.5.9 源码分析（三） ~ Vue初始化之选项的合并策略">
                    <i class="fa fa-qq" aria-hidden="true"></i><span>Share on QQ</span>
                </a>
            </li>
        
            
            
            <li class="share-option">
                <a class="share-option-btn" target="new" href="http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=http://mife.io/2018/08/10/Vue-2-5-9-源码分析（三）-Vue初始化之选项的合并策略/">
                    <i class="fa fa-star" aria-hidden="true"></i><span>Share on Qzone</span>
                </a>
            </li>
        
    </ul>
</div>

            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-remove"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/pic.jpg" alt="Author&#39;s picture"/>
        
            <h4 id="about-card-name">Mengyu&#39;s Notes</h4>
        
            <div id="about-card-bio"><p>一身情怀，两手空空</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>FE</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker"></i>
                <br/>
                Beijing
            </div>
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover-v1.2.0.jpg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/script-yhuo2grt8r7qkqumzgjoglkfbicl1thukjgmla6jopu56zpcowfedi5zjcor.min.js"></script>
<!--SCRIPTS END-->

    
        <script>
             var disqus_config = function () {
                 this.page.url = 'http://mife.io/2018/08/10/Vue-2-5-9-源码分析（三）-Vue初始化之选项的合并策略/';
                 
                    this.page.identifier = '2018/08/10/Vue-2-5-9-源码分析（三）-Vue初始化之选项的合并策略/';
                 
             };
            (function() {
                var d = document, s = d.createElement('script');
                var disqus_shortname = 'mife';
                s.src = '//' + disqus_shortname + '.disqus.com/embed.js';

                s.setAttribute('data-timestamp', +new Date());
                (d.head || d.body).appendChild(s);
            })();
        </script>
    



    </body>
</html>
